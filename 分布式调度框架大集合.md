# 分布式调度框架大集合

[原文链接](https://blog.csdn.net/u012379844/article/details/82716146)

## 分布式任务调度框架

1. 什么是分布式任务调度？
2. 常见的分布式任务调度框架有哪些？
3. 分布式任务调度框架的技术选型？
4. 分布式任务调度框架的安装与使用？

大对比表格：[分布式调度对比](分布式调度对比.md)

分布式任务调度，三个关键词：分布式、任务调度、配置中心。

- 分布式：平台是分布式部署的，各个节点之间可以无状态和无限的水平扩展；
- 任务调度：涉及到任务状态管理、任务调度请求的发送与接收、具体任务的分配、任务的具体执行；（这里又会遇到一共要处理哪些任务、任务要分配到哪些机器上处理、任务分发的时候判断哪些机器可以用等问题，所以又需要一个可以感知整个集群运行状态的配置中心）
- 配置中心：可以感知整个集群的状态、任务信息的注册

一个分布式任务调度系统需要以下内容：

1. Web模块：用来提供任务的信息，控制任务的状态、信息展示等。
2. Server模块：负责接收web端传来的任务执行的信息，下发任务调度请求给Scheduler，会去注册中心进行注册
3. Scheduler模块：接收server端传来的调度请求，将任务进行更加细化的拆分然后下发，到注册中心进行注册，获取到可以干活的worker。
4. Worker模块：负责具体的任务执行。
5. 注册中心。

### 1、什么是分布式任务调度？

任务调度是指基于给定的时间点，给定的时间间隔或者给定执行次数自动的执行任务。任务调度是是操作系统的重要组成部分，而对于实时的操作系统，任务调度直接影响着操作系统的实时性能。任务调度涉及到多线程并发、运行时间规则定制及解析、线程池的维护等诸多方面的工作。

WEB服务器在接受请求时，会创建一个新的线程服务。但是资源有限，必须对资源进行控制，首先就是限制服务线程的最大数目，其次考虑以线程池共享服务的线程资源，降低频繁创建、销毁线程的消耗；然后任务调度信息的存储包括运行次数、调度规则以及运行数据等。一个合适的任务调度框架对于项目的整体性能来说显得尤为重要。

### 2、常见的任务调度框架有哪些？

我们在实际的开发工作中，或多或少的都会用到任务调度这个功能。常见的分布式任务调度框架有：cronsun、Elastic-job、saturn、lts、TBSchedule、xxl-job等。

#### 2.1cronsun

crontab是Linux系统里面最简单易用的定时任务管理工具，在Linux上由crond来周期性的执行指令列表，执行的任务称为cron job，多个任务就称为crontab。crontab任务调度指令的基本格式为：

	*    *    *   *    *    command
	分   时   日   月   周   命令

但是时间久了之后会发现，crontab会存在一些问题：

1. 大量的crontab分散在各台服务器，带来了很高的维护成本；
1. 任务没有按时执行，过了很长的时间才能发现，需要重试或者排查；
1. crontab分散在很多集群上，需要一台一台的去查看日志；
1. crontab存在单点问题，对于不能重复执行的定时任务很伤脑；
1. ……

因此非常需要一个集中管理定时任务的系统，于是就有了cronsun。cronsun是一个分布式任务系统，单个节点和Linux机器上的contab近似，是为了解决多台Linux机器上crontab任务管理不方便的问题，同时提供了任务高可用的支持（当某个节点死机的时候可以自动调整到正常的节点执行）。与此同时，它还支持界面管理机器上的任务，支持任务失败邮件提醒，安装简单，使用简便，是替换crontab的一个不错的选择。

cronsun中主要有三个组件，都是通过etcd通讯的。cronnode负责节点的分组及节点的状态，cronweb是用来管理任务的、任务的执行结果都可以在上面看。

![](https://img-blog.csdn.net/20180915174325128?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNzk4NDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

cronsun的系统架构如下图所示，简单的来说就是，所有的任务都会存储在一个分布式etcd里，单个crond部署成一个服务，也就是图中所示的node.1、node.2、node.n等，然后再由web界面去管理。如果任务执行失败的话，会发送失败的邮件，当单个节点死机的时候，也会自动调整到正常的节点去执行任务。

![](https://img-blog.csdn.net/20180915174504763?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNzk4NDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

cronsun是在管理后台添加任务的，所以一旦管理后台泄漏出去了，则存在一定的危险性，所以cronsun支持security.json的安全设置：

	{
		"open": true,
		"#users": "允许选择运行脚本的用户", "users": [
		"www", "db" ],
		"#ext": "允许添加以下扩展名结束的脚本", "ext": [
		".cron.sh", ".cron.py" ]
	}

如以上设置开启安全限制，则添加和执行任务的时候只允许选择配置里面指定的用户来执行脚本，并且脚本的扩展名要在配置的脚本的扩展名限制的列表里面。

#### 2.2、Elastic-job

Elastic-job是当当开源的一款非常好用的作业框架，Elastic-job在2.x之后，出现了两个相互独立的产品线：Elastic-job-lite和Elastic-job-cloud。

##### 2.2.1、Elastic-job-lite

Elastic-job-lite定位为轻量级无中心化的解决方案，使用jar包的形式提供分布式任务的协调服务，外部依赖仅依赖于zookeeper。

![](https://img-blog.csdn.net/20180915174728651?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNzk4NDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

Elastic-job-lite的架构图如下图所示：

![](https://img-blog.csdn.net/2018091517483169?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNzk4NDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

从上面的框架图中可以看出，Elastic-job-lite框架使用zookeeper作为注册中心，Elastic-job-lite框架通过监听感知zookeeper数据的变化，并做相应的处理；运维平台也仅是通过读取zk数据来展现作业状态，或是更新zk数据修改全局配置。运维平台和Elastic-job-lite没有直接的关系，完全解耦合。Elastic-job-lite并不直接提供数据处理的功能，框架只会将分片项分配给各个正在运行中的服务器，分片项与真实数据的对应关系需要开发者在应用程序中自行处理。

Elastic-job-lite并无作业调度中心节点，而是基于部署作业框架的程序在到达相应时间点时各自触发调度。注册中心仅用于作业注册和监控信息存储，而主作业节点仅用于处理分片和清理的功能。

###### （1）注册中心的数据结构

![](https://img-blog.csdn.net/2018091517494627?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNzk4NDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

我们先来了解一下该框架在zookeeper上的节点情况。首先注册中心在命名的空间下创建作业名称节点（作业名称用来区分不同的作业，一旦修改名称，则认为是新的作业），作业名称节点下又包含5个子节点：

- config：保存作业的配置信息，以JSON格式存储
- sharding：保存作业的分片信息，它的子节点是分片项序号，从零开始，至分片总数减一
- leader：该节点保存作业服务器主节点的信息，分为election、sharding和failover三个子节点，分别用于主节点的选举、分片和失效转移
- instances：该节点保存的是作业运行实例的信息，子节点是当前作业运行实例的主键
- servers：该节点保存作业服务器的信息，子节点是作业服务器的IP地址

###### （2）实现原理

1. 第一台服务器上线触发主服务器选举，主服务器一旦下线，则重新触发选举，选举过程中阻塞，只有当主服务器选举完成，才会去执行其他的任务；
1. 某服务器上线时会自动将服务器的信息注册到注册中心，下线时会自动更新服务器的状态；
1. 主节点选举，服务器上下线，分片总数变更均更新重新分片标记；
1. 定时任务触发时，如需重新分片，则通过主服务器分片，分片过程中阻塞，分片结束后才可以执行任务。如分片过程中主服务器下线，则先选举主服务器在分片；
1. 由上一项说明可知，为了维持作业运行时的稳定性，运行过程中只会标记分片的状态，不会重新分片，分片仅可能发生在下次任务触发前；
1. 每次分片都会按照ip排序，保证分片结果不会产生较大的波动；
1. 实现失效转移功能，在某台服务器执行完毕后主动抓取未分配的分片，并且在某台服务器下线后主动寻找可用的服务器执行任务。

elastic底层的任务调度还是使用的quartz，通过zookeeper来动态给job节点分片。如果很大体量的用户需要我们在特定的时间段内计算完成，那么我们肯定是希望我们的任务可以通过集群达到水平的扩展，集群里的每个节点都处理部分的用户，不管用户的数量有多大，我们只需要增加机器就可以了。举个例子：比如我们希望3台机器跑job，我么将我们的任务分成3片，框架通过zk的协调，最终会让3台机器分配到0，1，2的任务片，比如server0->0、server1->1、server2->2，当server0执行时，可以只查询id%3==0的用户，server1可以只查询id%3==1的用户，server2可以只查询id%3==2的用户。

在以上的基础上再增加一个server3，此时，server3分不到任何的分片，没有分到任务分片的程序将不执行。如果此时server2挂了，那么server2被分到的任务分片将会分配给server3，所以server3就会代替server2执行。如果此时server3也挂了，那么框架也会自动的将server3的任务分片随机分配到server0或者server1，那么就可能成：server0->0、server1->1,2。

这种特性称之为**弹性扩容**。

##### 2.2.2、Elastic-job-cloud

Elastic-job-cloud包含了Elastic-job-lite的全部功能，它是以私有云平台的方式提供集资源、调度以及分片为一体的全量级解决方案，依赖于Mesos和Zookeeper，它额外提供了资源治理、应用分发以及进程隔离等服务。他们两个提供同一套API开发作业，开发者仅需一次开发，然后可根据需要以lite或cloud的方式部署。

#### 2.3、saturn

Saturn（定时任务调度系统）是唯品会自主研发的分布式的定时任务的调度平台，它是基于Elastic-job版本1开发的。目标是取代传统的Linux Cron/Spring Batch Job/Quartz的方式，做到全域统一配置、统一监控、任务高可用以及分片。Saturn的任务可以使用多种语言开发，比如python、Go、Shell、Java、Php等。

![](https://img-blog.csdn.net/20180915175048948?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNzk4NDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

Saturn包括两大部分，Saturn Console和Saturn Executor。Console是一个WEB UI，用来对作业/Executor的管理，统计报表展现等。他同时也是整个调度系统的大脑：将作业任务分配到各Executor。Executor是执行任务的worker：按照作业配置的要求去执行部署于Executor所在容器或物理机当中的作业脚本和代码。Saturn高度依赖于zookeeper，每个executor及调度服务都会在zookeeper上进行注册，确保调度程序能够及时得到executor的状态。

Saturn定时任务调度的最小单位是分片，即任务的一个执行单元。Saturn的基本任务就是将任务分成多个分片，并将每个分片通过算法调度到对应的executor上去执行。

##### 2.3.1、Staurn基本原理

Saturn的基本原理是将作业在逻辑上划分为若干个分片，通过作业分片调度器将作业分片指派给特定的执行节点。执行节点通过quartz触发执行作业的具体实现，在执行的时候，会将分片序号和参数作为参数传入。作业的实现逻辑需分析分片序号和分片参数，并以此为依据来调用具体的实现（比如一个批量处理数据库的作业，可以划分0号分片处理1-10号数据库，1号分片可以处理11-20号数据库）。

![](https://img-blog.csdn.net/20180915175139854?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNzk4NDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

##### 2.3.2、Saturn作业调度算法

（1）方案的设计

原理是给每个作业分片一个负载值和优先执行节点（prefer list），当需要重新分片时，参考作业优先设定和执行节点的负载值来进行域内节点之间的资源分配，从而达到资源平衡。

（2）前置条件

- 每个分片都引入一个负载值（load），由用户通过Saturn UI界面输入
- 为每一个作业引入新的属性prefer list（优先列表，或者叫欲分配列表），由管理员通过ui界面编辑
- 作业引入启用状态（enabled/disabled），用户通过UI界面改变这个状态；启用状态的作业会被节点执行，且不可编辑、删除，不可对prefer list进行调整，禁用状态的作业不会被执行

（3）实施步骤

1. 摘取；
1. 放回（将这些作业分片按照负载值从大到小顺序逐个分配给负载最小的执行节点）。

（3.1）executor上线

**摘取：**

1. 找出新上线节点的全部可执行作业列表；对于每个作业，判断prefer list中是否包含了新上线的节点；如果是，则摘取其中全部的分片；这些已经处理过的作业称为预处理作业；

1. 从新上线节点的作业列表中减去预分配作业，然后使用以下的方法依次摘取：

	假如上线的executor为a，它能处理的作业类型为j1，j2（已减去预分配列表）。遍历当前域下的executor列表，拿掉全部作业类型为j1，j2的分片，加上尚未分配的j1，j2作业分片列表，作为算法的待分配列表

	在处理每个节点时，每拿掉一个作业分片后判断被拿掉的负载（load）是否已经超过了自身处理前总负载（load）的1/n（n为当前executor节点的总数量），如果超过，则本执行节点摘取完成，继续处理下一个执行节点；如果不超过则继续摘取，直到超过（大于等于）为止。

**放回：**

1. 构造需要添加的作业分片列表，我们起名为待分配列表，长度为n，待分配列表按照负载（load）从大到小排序，排序时需保证相同作业的所有分片时连续的
1. 构造每种作业类型的executor列表（如果有prefer list，且有存活，则该作业的executor列表就是prefer list），得到一个map<jobName,executorList>’
1. 从待分配列表中依次取出第0到第n-1个作业分片jobi
1. 从map中取出可运行jobi的executor列表listi
1. 将jobi分配给listi中负载总和最小的executor

举例如下：

![](https://img-blog.csdn.net/20180915175230396?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIzNzk4NDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

（3.2）executor下线

摘取：取出下线的executor当前分配到的全部作业分片，作为算法的待分配列表

放回：使用平衡算法逐个处理待分配列表中的作业分片

（3.3）作业启动

摘取：从所有executor中摘取将被启动作业的全部分片作为算法的待分配列表

放回：使用调整后的平衡算法放回

（3.4）作业停止

摘取：将被停止的作业分片从各节点删除

返回：无

 
注：Saturn架构文档请见https://github.com/vipshop/Saturn/wiki/Saturn架构文档

