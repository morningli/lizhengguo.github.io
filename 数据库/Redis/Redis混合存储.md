# Redis混合存储

## 阿里云方案

### 整体架构

![](https://yqfile.alicdn.com/0525675d23c8362365643f1b09d80c42b98ae5a3.png)

#### 存储模型

![](https://yqfile.alicdn.com/e7067406ba357a464e69c29df1893814e2933075.png)

在Redis混合存储实例中，我们将所有的Key和经常访问的Value保留在内存中，将不经常访问的Value保存在磁盘上。之所以在内存中保留所有Key是处于以下两点考虑：

1.  Key的访问频度比Value要高很多。
	
	作为KV数据库，通常的访问请求都需要先查找Key确认Key是否存在，而要确认一个key不存在，就需要以某种形式检查所有Key的集合。在内存中保留所有Key，可以保证key的查找速度与纯内存版完全一致。
	
1. Key的大小占比很低。
	
	在通常的业务模型里面，即使是普通字符串类型，Value比Key要大几倍。而对于Set，List，Hash等集合对象，所有成员加起来组成的Value更是比Key大了好几个数量级。
	
Redis混合存储实例将所有的Key都认为是热数据，以少量的内存为代价保证所有Key的访问请求的性能是高效且一致的。而对于Value部分，Redis混合存储实例会在必要时根据最近访问时间，访问频度，Value本身大小等维度选取出一部分Value作为冷数据后台异步存储到磁盘上。

因此，Redis混合存储实例最适合以下使用场景：

1. 数据访问不均匀，存在热点数据；
1. 内存不足以放下所有数据，且Value较大(相对于Key而言)

#### 线程模型

![](https://yqfile.alicdn.com/c7163e3c9bd7d3495a6986fda8675e4f08a3e751.png)

Redis混合存储实例采用单工作线程的模式，主线程为工作线程，负责处理用户请求等主要逻辑。此外，Redis混合存储实例中根据需要会配置若干个独立的IO线程负责与磁盘进行交互读写数据，IO线程读写数据时，主线程仍可继续响应其它用户请求。

#### 数据从内存到磁盘

1. 在周期巡检函数serverCron中，如果发现当前内存快满了，大于设定的阈值vm-max-memory(略小于maxmemory)时，会尝试挑选出一些key，将其Value保存到磁盘；
1. 挑选的维度为最近访问时间和value大小, 公式为swappability = age*log(估算内存大小)。
1. 主线程为挑选出的value生成IO任务，加入到IO任务队列中；
1. IO线程会从IO任务队列中取出任务，将Value存储到底层存储引擎（RocksDB）中, 并通知主线程。
1. 主线程收到通知后释放Value所占用内存并标记内存中该Key对应的Value已被存储到磁盘上。