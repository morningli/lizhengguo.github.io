# 一致性模型(Consistency model)

[原文链接](https://en.wikipedia.org/wiki/Consistency_model)

在计算机科学中，一致性模型(consistency models)用于分布式系统，如分布式共享内存系统或分布式数据存储（例如文件系统，数据库，乐观复制系统或Web缓存）。如果内存操作遵循特定规则，则称该系统支持给定模型。数据一致性模型指定程序员和系统之间的契约，其中系统保证如果程序员遵守规则，内存将是一致的并且读取，写入或更新存储器的结果是可预测的。这与在高速缓存或无高速缓存的系统中发生的一致性(coherence)不同，是与所有处理器相关的数据的一致性。一致性(Coherence)处理的是维护一个全局顺序，其中所有处理器都可以看到对单个位置或单个变量的写入。一致性(Consistency )处理的是与所有处理器相关的多个位置的操作顺序。

高级语言，如c++和Java，通过将内存操作转换为保留内存语义的低级操作，在一定程度上维护了契约。为了遵守约定，编译器可能会重新排序一些内存指令，而pthread_mutex_lock()等库调用封装了所需的同步。

通常，无法通过模型检查(model check)来验证顺序一致性，即使对于有限状态高速缓存一致性(coherence)协议也是如此。

一致性模型(consistency models)规定了表面上的顺序和更新操作的可见性，是一个折衷的统一体。

## 示例

假设出现以下情况：

- 行X在节点M和N上冗余存储
- 客户端A将行X写入节点M.
- 在一段时间t之后，客户端B从节点N读取行X.

一致性模型必须确定客户端B是否看到来自客户端A的写入。

## 类型

有两种方法可以定义和分类一致性模型; 问题(issue)和视图(view)。

### 问题(issue)

问题方法描述了定义进程如何发出操作的限制。

### 视图(view)

视图方法，定义进程可见的操作顺序。

例如，一致性模型可以定义在完成所有先前发布的操作之前不允许进程发出操作。不同的一致性模型执行不同的条件。如果一个一致性模型需要该模型的所有条件，则可以认为它比另一个更强。换句话说，具有较少约束的模型被认为是较弱的一致性模型。

这些模型定义了硬件需要如何布局，以及更高级别，程序员必须如何编码。所选模型还会影响编译器重新排序指令的方式。通常，如果指令之间的控件依赖关系和对相同位置的写入是有序的，那么编译器可以根据需要重新排序。但是，对于下面描述的模型，有些可能允许在加载之前进行重新排序，而有些则可能没有。

### 严格一致

严格一致性是最强的一致性模型。在这种模式下，所有处理器都需要立即看到任何处理器对变量的写入。

严格的模型图和非严格的模型图描述了时间约束 - 瞬时。可以更好地理解，好像存在全局时钟，其中每个写入应该在该时钟周期结束时反映在所有处理器高速缓存中。下一个操作必须仅在下一个时钟周期内发生。

序列	严格的模型	非严格的模型
P 1	P 2	P 1	P 2
1	W（x）1		W（x）1	
2		R（x）1		R（x）0
3				R（x）1
这是最严格的模型。在此模型中，程序员的预期结果将每次都被接收。这是确定性的。

顺序一致性
该顺序一致性模型，提出了兰波特（1979年）。它是一种比严格一致性模型更弱的内存模型。不必立即看到对变量的写入，但是，所有处理器必须以相同的顺序看到不同处理器对变量的写入。正如Lamport（1979）所定义的那样，如果“任何执行的结果与所有处理器的操作以某种顺序执行相同，并且每个处理器的操作出现在此中，则满足顺序一致性[4]。序列按其程序指定的顺序排列。“

应保持每个处理器内的程序顺序和处理器之间的操作顺序排序。为了保持处理器之间的连续执行顺序，所有操作必须看起来相对于每个其他处理器即时或原子地执行。这些操作只需要“显示”即可完成，因为物理上不可能立即发送信息。例如，一旦发布了包含信息的总线，就可以保证所有处理器都能在同一时刻看到这些信息。因此，将信息传递到总线完成了对所有处理器的执行，并且似乎已经执行。具有非瞬时互连网络的无缓存体系结构或缓存体系结构可能包含处理器和存储器之间的慢速路径。这些慢速路径可能导致顺序不一致，因为某些存储器比其他存储器更快地接收广播数据。

顺序一致性可以产生非确定性结果。这是因为在程序的不同运行期间，处理器之间的顺序操作序列可以是不同的。所有内存操作都需要按程序顺序进行。

线性化（也称为原子一致性）可以定义为与实时约束的顺序一致性。

因果一致性
因果一致性是一种弱化的序贯一致性模型，它将事件分类为因果关系和非事件相关。它定义了只有与因果相关的写操作才需要被所有进程以相同的顺序看到。

该模型放松了处理器对并发写入的顺序一致性以及与非因果关系的写入。如果对变量的一次写入依赖于先前对任何变量的写入，如果执行第二次写入的处理器刚刚读取了第一次写入，则两次写入可能会因果关系。这两次写操作可以由同一处理器或不同的处理器完成。

与顺序一致性一样，读取不需要即时反映更改，但是，它们需要按顺序反映变量的所有更改。

序列	P 1	P 2
1	W 1（x）3	
2		W 2（x）5
3		R 1（x）3
W 1与W 2没有因果关系。R1将依次不一致，但因果关系一致。[ 需要澄清 ] [5]

序列	P 1	P 2	P 3	P 4
1	W（x）的1	R（x）的1	R（x）的1	R（x）的1
2		W（X）2		
3	W（X）3		R（X）3	R（X）2
4			R（X）2	R（X）3
由于在W（x）2之前由P2到x进行读取，W（x）1和W（x）2是因果相关的。[5]

处理器一致性
为了保持数据的一致性并获得每个处理器都有自己的存储器的可扩展处理器系统，导出了处理器一致性模型。[5] 所有处理器需要按照它们看到由一个处理器完成的写入的顺序以及它们看到不同处理器向同一位置写入的方式（保持一致性）保持一致。但是，当不同处理器写入不同位置时，它们不需要保持一致。

每个写操作可以分成几个子写到所有存储器。在写入该存储器之前，可以从一个这样的存储器读取。因此，读取的数据可能是陈旧的。因此，当旧商店需要停止时，PC下的处理器可以执行更年轻的负载。在写入之前读取，在读取和写入之前读取，在此模型中仍保留写入顺序。

处理器一致性模型[6]类似于PRAM一致性模型，具有更强的条件，该条件定义所有其他进程必须以相同的顺序顺序查看对同一存储器位置的所有写入。处理器一致性弱于顺序一致性，但强于PRAM一致性模型。

在斯坦福DASH多处理器系统实现的处理器一致性古德曼的定义的变化，其是无与伦比的（既不弱也不强）。[7]所有处理器需要按照它们看到一个处理器写入的顺序以及它们看到不同处理器写入同一位置的方式保持一致。但是，当不同处理器写入不同位置时，它们不需要保持一致。

流水线RAM一致性或FIFO一致性
Lipton和Sandberg在1988年[8]提出了流水线RAM一致性（PRAM一致性） 作为最初描述的一致性模型之一。由于其非正式的定义，实际上至少有两种略有不同的实现，[7] Ahamad等人的实现。还有一个是莫斯伯格。

在PRAM一致性中，所有进程按照该进程发出的顺序查看单个进程的操作，而不同进程发出的操作可以按不同进程的不同顺序查看。PRAM一致性弱于处理器一致性。PRAM放松了在所有处理器上保持一致性的需要。这里，可以在处理器中写入之前执行对任何变量的读取。在写入之前读取，在读取和写入之前读取，在此模型中仍保留写入顺序。

序列	P 1	P 2	P 3	P 4
1	W（x）的1			
2		R（x）的1		
3		W（X）2		
4			R（x）的1	R（X）2
五			R（X）2	R（x）的1
缓存一致性
高速缓存一致性[6] [9]要求对同一存储器位置的所有写操作都按某种顺序执行。缓存一致性比流程一致性弱，并且与PRAM一致性无法比拟。

缓慢的一致性

记忆力慢
在慢一致性中，[9]如果进程读取先前写入内存位置的值，则它随后不能从该位置读取任何先前的值。由进程执行的写入对该进程立即可见。缓慢一致性是比PRAM和缓存一致性更弱的模型。

示例： 慢速内存图描绘了一个缓慢的一致性示例。第一个进程将1写入内存位置X，然后将1写入内存位置Y.第二个进程从Y读取1，然后从X读取0，即使X在Y之前写入。

Hutto，Phillip W.和Mustaque Ahamad（1990）[10]说明通过适当的编程，慢记忆（一致性）可以表达和有效。他们提到慢速记忆有两个有价值的特性; 地方性和支持从原子记忆中减少。他们提出了两种算法来表示慢记忆的表现力。

以下型号需要程序员进行特定同步。

弱订购
程序顺序和原子性仅在一组操作上维护，而不是在所有读取和写入上维护。这是因为理解某些内存操作 - 例如在关键部分中进行的操作 - 不需要所有处理器都能看到 - 直到完成关键部分中的所有操作之后。它还利用了这样一个事实，即在多处理器系统上执行的程序包含所需的同步，以确保不会发生数据争用并始终产生SC结果。因此，在弱排序中，除了同步操作之外的操作可以被分类为数据操作。[11]

P 1	P 2
X = 1;
篱笆
 
xready = 1;
篱笆
while（！xready）{}; 
 
篱笆
 
y = 2;
同步操作向处理器发出信号，以确保它已完成并看到所有处理器完成的所有先前操作。为了保持弱排序，必须在同步操作之前全局执行同步操作之前的写操作。同步操作之后的操作也应仅在同步操作完成后执行。因此，对同步变量的访问是顺序一致的，并且只有在先前的同步操作完成之后才应执行任何读或写。在这个模型中，连贯性并不宽松。满足这些要求后，可以重新排序所有其他“数据”操作。

在程序中高度依赖显式同步。对于弱排序模型，程序员必须使用原子锁定指令，例如测试和设置，获取和操作，存储条件，加载链接或必须标记同步变量或使用栅栏。

发布一致性
在释放一致性模型从出口同步操作区分入口同步操作放松弱一致性模型。在弱排序下，当要看到同步操作时，在完成同步操作并且处理器继续进行之前，所有处理器中的所有操作都需要是可见的。但是，在发布一致性模型下，在进入关键部分（称为“获取”）期间，需要完成与本地内存变量相关的所有操作。在退出期间，称为“释放”，本地处理器所做的所有更改都应传播到所有其他处理器。仍然保持一致性。

获取操作是为访问临界区而执行的加载/读取。释放操作是执行存储/写入以允许其他处理器使用共享变量。

在同步变量中，可以保持顺序一致性或处理器一致性。使用SC，应按顺序处理所有竞争同步变量。但是，对于PC，一对竞争变量只需遵循此顺序。较旧的版本之前可以允许更年轻的获取。[12]

条目一致性
这是版本一致性模型的变体。它还需要使用获取和释放指令来明确说明进入或退出关键部分。但是，在条目一致性下，每个共享变量都会分配一个特定于它的同步变量。这样，只有当获取是变量x时，才需要针对该处理器完成与x相关的所有操作。这允许发生不同共享变量的不同关键部分的并发操作。对于同一共享变量的关键操作，无法看到并发。当可以同时处理不同的矩阵元素时，这种一致性模型将是有用的。

一般一致性
在一般的一致性中，[13]在完成所有进程的写入之后，内存位置的所有副本最终都是相同的。

本地一致性
在本地一致性中，[9]每个进程按其程序定义的顺序执行自己的操作。对其他进程的写操作似乎执行的顺序没有限制。本地一致性是共享内存系统中最弱的一致性模型。

其他一致性模型
其他一些一致性模型如下：

原因+一致性 [14] [15]
达美一致性
最终的一致性
叉一致性
单拷贝可串行化
串行化
矢量场一致性
一致性差
一致性强
已经设想了若干其他一致性模型来表达关于操作的排序或可见性的限制，或者处理特定的故障假设。[16]

轻松的记忆一致性模型
可以通过放松称为宽松一致性模型的顺序一致性中的一个或多个需求来定义一些不同的一致性模 [17]这些一致性模型不提供硬件级别的内存一致性。实际上，程序员负责通过应用同步技术来实现内存一致性。以上模型基于四个标准进行分类，并进一步详述。

有四种比较来定义宽松的一致性：

松弛
对松弛一致性进行分类的一种方法是定义放宽哪些顺序一致性要求。我们可以通过放宽由Adve和Gharachorloo，1996定义的程序顺序或写原子性要求来设置不太严格的模型。[18]程序顺序保证每个进程发出由其程序排序的内存请求，并且写入原子性定义内存请求是基于服务的在单个FIFO队列的顺序上。在放松程序顺序中，可以放宽操作对，写后写，读后读或读/写后读的任何或所有顺序。在轻松写入原子性模型中，进程可以在任何其他处理器之前查看自己的写入。
同步与非同步
可以通过将存储器访问分成两组并为每个组分配不同的一致性限制来定义同步模型，考虑到一个组可以具有弱一致性模型而另一个组需要更严格的一致性模型。相反，非同步模型将相同的一致性模型分配给内存访问类型。
问题与基于视图
[9]问题方法通过定义发布内存操作的进程的限制来提供顺序一致性模拟。而view方法描述了对进程的事件顺序的可见性限制。
相对模型强度
某些一致性模型比其他模型更具限制性。换句话说，严格的一致性模型强制执行更多约束作为一致性要求。模型的强度可以通过程序顺序或原子性松弛来定义，并且还可以比较模型的强度。如果某些模型应用相同的松弛或更多，则它们直接相关。另一方面，放松不同要求的模型并不直接相关。
顺序一致性有两个要求，即程序顺序和写入原子性。通过放宽这些要求可以获得不同的松弛一致性模型。这样做是为了在放松约束的同时提高性能，但程序员负责通过应用同步技术来实现内存一致性，并且必须对硬件有很好的理解。

潜在的放松：

写入以读取程序顺序
写入编写程序顺序
读取读取和读取以编写程序命令
放松模型
以下模型是轻松一致性的一些模型：

轻松写入阅读
提高硬件级性能的方法是放松写入的PO，然后读取，这有效地隐藏了写入操作的延迟。这种类型的放松所依赖的优化是它允许后续读取相对于来自处理器的先前写入处于放松顺序。由于这种放松，一些程序如XXX可能因为这种放松而无法给出SC结果。然而，由于执行剩余的程序顺序限制，YYY等程序仍然可以提供一致的结果。

三种型号属于这一类。IBM 370模型是最严格的模型。读取可以在较早写入不同地址之前完成，但除非所有处理器都看到写入，否则禁止返回写入值。SPARC V8总商店订购模型（TSO）模型部分放宽了IBM 370 Model，它允许读取返回其自己的处理器写入的值相对于对同一位置的其他写入，即它返回其自己的写入值之前别人看到了。与之前的模型类似，除非所有处理器都看到了写入，否则这不能返回写入值。处理器一致性模型（PC）是三种模型中最放松的，并且放宽了约束，使得即使在对其他处理器可见之前，读取也可以在较早的写入之前完成。

在示例A中，结果仅在IBM 370中可行，因为在完成该处理器中的写入（A）之前不会发出read（A）。另一方面，这种结果在TSO和PC中是可能的，因为它们允许在单个处理器中写入标志之前读取标志。

在例B中，结果只能用于PC，因为它允许P2在P3可见之前返回写入值。这在其他两个型号中是不可能的。

为确保上述模型的顺序一致性，使用安全网或围栏手动强制执行约束。IBM370模型有一些专门的序列化指令在操作之间手动放置。这些指令可以包括存储器指令或非存储器指令，例如分支。另一方面，TSO和PC型号不提供安全网，但程序员仍然可以使用读 - 修改 - 写操作使其看起来像在写和后续读之间仍保持程序顺序。在TSO的情况下，如果已经是R-modify-W的一部分的R或W被R-modify-W替换，则似乎维持PO，这要求R-modify-W中的W是a 'dummy'返回读取值。类似地，对于PC，如果读取被写入替换或者已经是R-modify-W的一部分，则似乎保持PO。

但是，仅在单独放松之后，编译器优化就无法完成。编译器优化需要完全灵活地重新排序PO中的任何两个操作，因此在这种情况下，针对读取重新排序写入的能力不够充分。

例A
P 1	P 2
A = flag1 = flag2 = 0
flag1 = 1	flag2 = 1
A = 1	A = 2
reg1 = A.	reg3 = A.
reg2 = flag2	reg4 = flag1
reg1 = 1; reg3 = 2，reg2 = reg4 = 0
例B
P 1	P 2	P 3
A = B = 0
A = 1		
如果（A == 1）	
B = 1	如果（B == 1）
reg1 = A.
B = 1，reg1 = 0
轻松写入读写写入
有些模型通过放宽写入不同位置之间的排序约束来进一步放宽程序顺序。SPARC V8部分商店订购模型（PSO）是此类模型的唯一示例。管道和重叠写入来自同一处理器的不同位置的能力是PSO启用的关键硬件优化。PSO在原子性要求方面类似于TSO，因为它允许处理器读取其自身写入的值并防止其他处理器在写入对所有其他处理器可见之前读取另一个处理器的写入。PSO使用显式STBAR指令维护两次写入之间的程序顺序。在使用FIFO写缓冲区的实现中，STBAR被插入写缓冲区。计数器用于确定何时STBAR指令之前的所有写操作都已完成，这会触发对存储器系统的写操作以递增计数器。写确认会递减计数器，当计数器变为0时，表示所有先前的写操作都已完成。

在实施例A和B中，PSO允许这两种非顺序一致的结果。PSO提供的安全网类似于TSO，它强制执行从写入到读取的程序顺序并强制执行写入原子性。

与之前的模型类似，PSO允许的松弛不够灵活，无法用于编译器优化，这需要更灵活的优化。

放松阅读和读写程序订单
在某些型号中，放松了对不同位置的所有操作。可以针对不同的读取或写入在不同的位置重新排序读取或写入。该弱排序可以归入此类别，并且这种模型也有两种类型的释放一致性模型（RCsc和RCpc）。在这种放松类别下还提出了三种商业架构：Digital Alpha，SPARC V9轻松内存订单（RMO）和IBM PowerPC型号。所有这些模型都允许将读取重新排序到同一位置，但Digital Alpha除外。这些模型违反了示例A和B中的顺序次序。在先前模型中不存在的这些模型中允许的额外放宽是读取操作之后的存储器操作可以相对于读取重叠和重新排序。所有这些模型，期望RCpc和PowerPC，允许读取返回另一个处理器的早期写入的值。来自程序员'

根据所提供的安全网类型，这些模型可分为两类。在这里，可以看到精心编写的程序的必要性。同步的性质有助于在弱排序，RCsc和RCpc模型之间进行分类。Alpha，RMO和PowerPC模型提供了栅栏指令，因此可以在不同的存储器操作之间施加程序顺序。

弱订购
放松大部分上述约束的模型的一个例子（除了早期阅读其他人的写法）是弱排序。它将内存操作分为两类：数据操作和同步操作。为了强制执行程序顺序，程序员需要在程序中找到至少一个同步操作。这种方法的假设是，在同步操作之间将数据区域的内存操作重新排序不会影响程序的结果。它们只是作为执行程序订单的安全网。其工作方式是计数器跟踪数据操作的数量，并且在该计数器变为零之前，不发出同步操作。此外，除非完成所有先前的同步，否则不再发出数据操作。两个同步变量之间的存储器操作可以重叠和重新排序，而不会影响程序的正确性。此模型确保始终保持写入原子性，

发布一致性：RCsc和RCpc 
有两种类型的发布一致性，发布一致性与顺序一致性（RCsc）和发布一致性与处理器一致性（RCpc）。后一种类型表示哪种类型的一致性适用于下面提到的特殊操作。

有特殊的（参见普通）内存操作，本身包括两个类操作的：同步或Nsync时操作。后者是不用于同步的操作; 前者是，并且包括获取和释放操作。获取实际上是用于获得对某组共享位置的访问的读取存储器操作。另一方面，释放是为了授予访问共享位置的权限而执行的写入操作。

对于顺序一致性（RCsc），约束是：

获取→全部，
全部→发布，
特别→特别。
对于处理器一致性（RCpc），写入读取程序顺序是放宽的，具有约束：

获取→全部，
全部→发布，
特殊→特殊（期望特殊写入后跟特殊读取）。
注意：上述符号A→B表示如果操作A在程序顺序中位于B之前，则强制执行程序顺序。

Alpha，RMO和PowerPC 
这三种商业架构展示了明确的围栏指令作为其安全网。Alpha模型提供两种类型的栅栏指令，即内存屏障（MB）和写入内存屏障（WMB）。MB操作可用于在屏障之后具有存储器操作的MB之前维持任何存储器操作的程序顺序。类似地，WMB仅在写入之间维护程序顺序。SPARC V9 RMO模型提供MEMBAR指令，可以对其进行定制，以便根据将来的读写操作对先前的读取和写入进行排序。不需要使用读取 - 修改 - 写入来实现此顺序，因为MEMBAR指令可用于针对后续读取命令写入。PowerPC模型使用称为SYNC指令的单个fence指令。它类似于MB指令，但有一点例外，即使SYNC位于同一位置的两次读取之间，读取也可能在程序顺序之外发生。该模型在原子性方面也与Alpha和RMO不同。它允许在读取完成之前看到写入。可能需要读取修改写入操作的组合来产生写入原子性的错觉。

事务性内存模型
事务性内存模型[17]是高速缓存一致性和内存一致性模型的组合，作为软件或硬件支持的共享内存系统的通信模型; 事务内存模型提供内存一致性和缓存一致性。事务是由将数据从一个一致状态转换为另一个状态的进程执行的一系列操作。事务在没有冲突或中止时提交。在提交中，当事务完成时，所有其他进程都可以看到所有更改，而中止会丢弃所有更改。与宽松一致性模型相比，事务模型更易于使用，并且可以提供比顺序一致性模型更高的性能。

一致性和复制
Tanenbaum等人，2007 [19]定义了复制的两个主要原因; 可靠性和性能。通过在当前副本失败的情况下切换到另一个副本，可以在复制文件系统中实现可靠性。复制还通过在不同副本上提供多个数据副本来保护数据不被破坏。它还通过划分工作来提高性能。虽然复制可以提高性能和可靠性，但它可能会导致多个数据副本之间出现一致性问题。如果读取操作从所有副本返回相同的值，并且作为单个原子操作（事务）的写入操作在任何其他操作发生之前更新所有副本，则多个副本是一致的。Tanenbaum，Andrew和Maarten Van Steen，2007 [19]将这种类型的一致性称为同步复制提供的紧密一致性。但是，应用全局同步以保持所有副本的一致性是昂贵的。降低全局同步成本和提高性能的一种方法可能会削弱一致性限制。

以数据为中心的一致性模型
Tanenbaum等人，2007 [19]将一致性模型定义为软件（流程）和内存实现（数据存储）之间的契约。此模型保证如果软件遵循某些规则，则内存可正常工作。因为在没有全局时钟的系统中，难以定义写入中的最后操作，所以可以对读取操作可以返回的值应用一些限制。

一致的操作顺序
某些一致性模型（如顺序和因果一致性模型）处理共享复制数据的操作顺序，以提供一致性。在此模型中，所有副本必须就更新的一致全局排序达成一致。

顺序一致性
以数据为中心的一致性模型的目标是在数据存储上提供一致的视图，其中进程可以执行并发更新。一个重要的以数据为中心的一致性模型是Lamport（1979）定义的顺序一致性。[4] Tanenbaum等人，2007 [19]定义了以下条件下的顺序一致性：

任何执行的结果都与数据存储上的所有进程的（读取和写入）操作按某种顺序执行并且每个单独进程的操作按其程序指定的顺序出现在此序列中相同。[19]

Adve和Gharachorloo，1996 [18]定义了实现顺序一致性的两个要求; 程序顺序和写原子性。

程序顺序：程序顺序保证每个进程发出由其程序排序的内存请求。
写入原子性：写入原子性定义了基于单个FIFO队列的顺序来服务内存请求。
在顺序一致性中，没有时间概念或最近的写操作。对于所有进程，存在一些相同的操作交错。进程可以看到所有进程的写操作，但它只能看到自己的读操作。

线性化[20]（原子存储器）[17]可以通过考虑每个操作的开始时间和结束时间来定义为具有实时约束的顺序一致性。如果每个操作通过在其开始时间和结束时间之间放置一个点以线性化顺序进行并且保证顺序一致性，则执行是可线性化的。

因果一致性
由Hutto和Ahamad，1990 [10 ]定义的因果一致性[19]是一种较弱的一致性模型，而不是顺序一致性，它通过区分因果相关的操作和那些不相关的操作。例如，如果事件b从先前的事件a生效，则因果一致性保证所有进程在事件a之后看到事件b。

Tanenbaum等人，2007 [19]定义了在以下条件下数据存储被认为是因果一致的：

必须以相同顺序查看所有可能因果关系的写入。可以在不同的机器上以不同的顺序看到并发写入。[19]

分组操作[19]
在分组操作中，对同步变量的访问是顺序一致的。允许进程访问所有先前写入已完成的同步变量。换句话说，在完全执行对同步变量的所有操作之前，不允许访问同步变量。

持续一致
连续一致性稍后在一致性协议部分中定义。

以客户为中心的一致性模型[19]
在分布式系统中，维护顺序一致性以控制并发操作至关重要。在一些没有同步更新的特殊数据存储中，以客户为中心的一致性模型可以以较低成本的方式处理不一致。以下模型是一些以客户为中心的一致性模型：

最终的一致性
一个最终一致性[19]是与缺乏同时更新的系统的弱一致性模型。它定义了如果没有更新需要很长时间，所有副本最终都会变得一致。

大多数共享的分散式数据库都有一个最终的一致性模型，BASE：基本可用; 软状态; 最终是一致的，或者ACID和BASE 的组合有时称为SALT：顺序; 同意; ledgered; 防篡改，也是对称的; 管理无; ledgered; 和时间一致的。[21] [22] [23]

单调读取一致性
Tanenbaum等人，2007 [19]将单调读取一致性定义如下：

“如果进程读取数据项x的值，则该进程对x的任何连续读取操作将始终返回相同的值或更新的值。” [19]

单调读取一致性保证在进程在时间t读取数据项x的值之后，它将永远不会看到该数据项的旧值。

单调写一致性
单调写一致性条件由Tanenbaum等人，2007 [19]定义如下：

“通过相同的过程在X上进行任何连续写操作之前，完成数据项X上的进程的写操作。” [19]

读写一致性
由进程写入数据项X的值将始终可用于由数据项X上的相同进程执行的连续读取操作。[19]

写入跟随读取一致性
在写入 - 跟随 - 读取一致性中，在执行先前的读取操作之后传播更新。Tanenbaum等人，2007 [19]定义了写入跟随读取一致性的以下条件：

“通过相同的过程对x上的先前读取操作之后的数据项x上的进程进行的写操作保证发生在读取的相同或更近的x值上。” [19]

一致性协议
一致性模型的实现由一致性协议定义。Tanenbaum等人，2007 [19]说明了以数据为中心的模型的一些一致性协议。

持续一致
Yu和Vahdat（2000）引入了持续一致性。[24]在这个模型中，应用程序的一致性语义通过在应用程序中使用conits说明。由于一致性要求可能因应用语义而异，Yu和Vahdat（2000）[24]认为预定义的统一一致性模型可能不是一种合适的方法。应用程序应指定满足应用程序语义的一致性要求。在此模型中，应用程序将每个一致性要求指定为conits（一致性单位的缩写）。conit可以是物理或逻辑一致性，用于衡量一致性。Tanenbaum等人，2007 [19]通过举例说明了一个conit的概念。

应用程序可以容忍三种不一致。

数值偏差[24]
数值偏差限制了conit值与上次更新的相对值之间的差异。可以为写入分配权重，该权重定义了特定应用程序中写入的重要性。可以将conit的看不见写入的总权重定义为应用程序中的数字偏差。有两种不同类型的数值偏差; 绝对和相对数值偏差。
订购偏差[24]
排序偏差是副本中的本地写入顺序与最终最终图像中的相对排序之间的差异。
复制品之间的陈旧性差异[24]
Staleness偏差通过限制当前时间与本地未见的conit上最早写入时间之间的差异来定义最早写入的有效性。每个服务器都有一个不确定写入的本地队列，需要确定并应用于conit的实际订单。不确定写入队列的最大长度是有序偏差的界限。当写入次数超过限制时，服务器将尝试通过根据应执行写入的顺序与其他服务器通信来尝试提交不确定的写入，而不是接受新提交的写入。
如果所有三个偏差界限都设置为零，则连续一致性模型是强一致性。

基于主要的协议

主备份协议

主备份协议（本地写入）
基于主要的协议[19]可以被认为是一类易于实现的一致性协议。例如，当考虑一致的操作顺序时，顺序排序是一种流行的一致性模型。可以将顺序排序确定为基于主要的协议。在这些协议中，数据存储中的每个数据项都有一个关联的主数据库，用于协调对该数据项的写操作。

远程写协议
在支持复制的最简单的基于主的协议（也称为主备份协议）中，写操作被转发到单个服务器，并且可以在本地执行读取操作。

示例： Tanenbaum等，2007 [19]给出了主备份协议的示例。主备份协议图显示了此协议的示例。当客户端请求写入时，写入请求将转发到主服务器。主服务器向备份发送请求以执行更新。然后，服务器从所有备份接收更新确认，并向客户端发送写入完成确认。任何客户端都可以在本地读取上次可用的更新 此协议的权衡是发送更新请求的客户端可能需要等待很长时间才能获得确认才能继续。可以通过在本地执行更新来解决此问题，然后请求其他备份执行其更新。非阻塞主备份协议不保证所有备份服务器上的更新一致性。然而，它提高了性能。在主备份协议中，所有进程都将看到相同的写操作顺序，因为此协议根据全局唯一时间对所有传入写入进行排序。阻塞协议保证进程查看上次写操作的结果。
本地写协议
在基于主的本地写协议中， [19]主副本在愿意执行更新的进程之间移动。要更新数据项，进程首先将其移动到其位置。结果，在该方法中，可以在本地执行连续的写操作，同时每个进程可以读取它们的数据项的本地副本。主数据库完成更新后，更新将转发到其他副本，并且所有副本都在本地执行更新。这种非阻塞方法可以带来改进。本地写协议的图表描述了基于主协议的本地写入方法。进程请求数据项x中的写操作。当前服务器被视为数据项x的新主要服务器。执行写操作，当请求完成时，主服务器向其他备份服务器发送更新请求。

复制写协议
在复制写协议[19]中，与基于主协议的不同，所有更新都是对所有副本执行的。

主动复制
在主动复制中，[19]存在与每个副本相关联的进程以执行写操作。换句话说，更新以操作的形式发送到每个副本以便执行。所有更新都需要在所有副本中以相同的顺序执行。结果，需要完全有序的多播机制。在大型分布式系统中实现这种多播机制存在可扩展性问题。还有另一种方法，其中每个操作被发送到中央协调器（定序器）。协调器首先为每个操作分配序列号，然后将操作转发给所有副本。第二种方法也不能解决可扩展性问题。

基于法定人数的协议[19]
投票可以是复制写协议中的另一种方法。在此方法中，客户端请求并从多个服务器接收权限，以便读取和写入复制的数据。例如，假设在分布式文件系统中，文件在N个服务器上复制。要更新文件，客户端必须至少向N / 2 + 1发送请求才能同意执行更新。在协议之后，对文件应用更改，并为更新的文件分配新的版本号。类似地，为了读取复制文件，客户端向N / 2 + 1服务器发送请求，以便从这些服务器接收关联的版本号。如果所有收到的版本号都是最新版本，则读取操作完成。

缓存一致性协议
在复制文件系统中，缓存一致性协议[19]提供缓存一致性，而缓存通常由客户端控制。在许多方法中，高速缓存一致性由底层硬件提供。基于中间件的分布式系统中的一些其他方法应用基于软件的解决方案来提供缓存一致性。

缓存一致性模型的一致性检测策略可能不同，这些策略定义何时出现不一致。检测不一致性有两种方法; 静态和动态解决方案。在静态解决方案中，编译器确定哪些变量可能导致缓存不一致。因此，编译器强制执行指令以避免不一致问题。在动态解决方案中，服务器在运行时检查不一致性，以控制缓存后已更改的缓存数据的一致性。

一致性执行策略是另一种缓存一致性协议。它定义了如何使用位于服务器上的副本在缓存中提供一致性。保持数据一致的一种方法是永远不要缓存共享数据。服务器可以保留数据并应用一些一致性协议，例如基于主协议，以确保共享数据的一致性。在此解决方案中，客户端只能缓存私有数据。在共享数据被缓存的情况下，有两种方法来强制执行缓存一致性。

在第一种方法中，当更新共享数据时，服务器将失效转发给所有高速缓存。在第二种方法中，传播更新。大多数缓存系统都应用这两种方法或在它们之间动态选择。

另见
缓存一致性
分布式共享内存
非统一内存访问